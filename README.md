## Инструкция по выполнению проекта
## 1. Постройте витрину для RFM-анализа
Вам дали доступ к базе данных компании. В базе две схемы: production и analysis. В схеме production содержатся оперативные таблицы.
Задача — построить витрину для RFM-классификации. Для анализа нужно отобрать только успешно выполненные заказы.
### 1.1. Выясните требования к целевой витрине
1. Витрина должна располагаться в той же базе в схеме analysis.
2. Витрина должна состоять из таких полей:
* user_id
* recency (число от 1 до 5)
* frequency (число от 1 до 5)
* monetary_value (число от 1 до 5)
3. В витрине нужны данные с начала 2022 года.
4. Назовите витрину dm_rfm_segments.
5. Это заказ со статусом Closed.
### 1.2. Изучите структуру исходных данных
1. Подключитесь к базе данных и изучите структуру таблиц.
2. Дополните документ requirements.md, в котором будете описывать решение. В этом же документе зафиксируйте, какие поля вы будете использовать для расчёта витрины.
### 1.3. Проанализируйте качество данных
1. Изучите качество входных данных.
2. В итоговом документе data_quality.md опишите, насколько качественные данные хранятся в источнике.
3. Укажите, какие инструменты для обеспечения качества данных использованы в таблицах в схеме production.
### 1.4. Подготовьте витрину данных
Теперь, когда требования понятны, а исходные данные изучены, можно приступить к реализации.
1. Сделайте представление для таблиц из базы production.
Вас попросили обращаться только к объектам из схемы analysis при расчёте витрины. Чтобы не дублировать данные, которые находятся в этой же базе, сделайте представления. Представления будут находиться в схеме analysis и отображать данные из схемы production.
Напишите SQL-запросы, чтобы создать пять представлений (по одному на каждую таблицу), и выполните их. В итоговый документ вставьте код создания представления.
Создайте документ views.sql. В этот документ вставьте код создания представлений.
2. Напишите DDL-запрос для создания витрины.
Далее вам необходимо создать витрину. Напишите запрос с CREATE TABLE и выполните его на предоставленной базе данных в схеме analysis. Помните, что при создании таблицы необходимо учитывать названия полей, типы данных и ограничения.
Создайте документ datamart_ddl.sql и сохраните в него написанный запрос.
3. Напишите SQL-запрос для заполнения витрины
Реализуйте расчёт витрины на языке SQL и заполните таблицу, созданную в предыдущем пункте. Для решения предоставьте код запроса.
Рассчитайте витрину поэтапно. Сначала заведите таблицы под каждый показатель:
```SQL
CREATE TABLE analysis.tmp_rfm_recency (
 user_id INT NOT NULL PRIMARY KEY,
 recency INT NOT NULL CHECK(recency >= 1 AND recency <= 5)
);
CREATE TABLE analysis.tmp_rfm_frequency (
 user_id INT NOT NULL PRIMARY KEY,
 frequency INT NOT NULL CHECK(frequency >= 1 AND frequency <= 5)
);
CREATE TABLE analysis.tmp_rfm_monetary_value (
 user_id INT NOT NULL PRIMARY KEY,
 monetary_value INT NOT NULL CHECK(monetary_value >= 1 AND monetary_value <= 5)
);
```  
После этого создайте документ tmp_rfm_recency.sql. В нём напишите SQL-запрос для заполнения таблицы analysis.tmp_rfm_recency.
Повторите алгоритм для двух следующих показателей. В документе tmp_rfm_frequency.sqlнапишите SQL-запрос для заполнения таблицы analysis.tmp_rfm_frequency, а в документе tmp_rfm_monetary_value.sql — SQL-запрос для заполнения таблицы analysis.tmp_rfm_monetary_value.

Затем создайте документ datamart_query.sql и напишите в нём запрос, который на основе данных, подготовленных в таблицах analysis.tmp_rfm_recency, analysis.tmp_rfm_frequency и analysis.tmp_rfm_monetary_value, заполнит витрину analysis.dm_rfm_segments.

Скопируйте в этот же файл первые десять строк из полученной таблицы, отсортированные по user_id. Это значит, что нужно скопировать user_id и соответствующие им параметры RFM для 10 пользователей с минимальными user_id.
## 2. Доработка представлений
Витрина готова. Вы сдали её заказчикам.
Через некоторое время вам пишет менеджер и сообщает, что витрина больше не собирается. Вы начинаете разбираться, в чём причина, и выясняете, что бэкенд-разработчики приложения обновили структуру данных в схеме production: в таблице Orders больше нет поля статуса. А это поле необходимо, потому что для анализа нужно выбрать только успешно выполненные заказы со статусом closed.

Вместо поля с одним статусом разработчики добавили таблицу для журналирования всех изменений статусов заказов — production.OrderStatusLog.

Структура таблицы production.OrderStatusLog:
* id — синтетический автогенерируемый идентификатор записи,
* order_id — идентификатор заказа, внешний ключ на таблицу production.Orders,
* status_id — идентификатор статуса, внешний ключ на таблицу статусов заказов production.OrderStatuses,
* dttm — дата и время получения заказом этого статуса.
Чтобы ваш скрипт по расчёту витрины продолжил работать, вам необходимо внести изменения в то, как формируется представление analysis.Orders: вернуть в него поле status. Значение в этом поле должно соответствовать последнему по времени статусу из таблицы production.OrderStatusLog.

Для проверки предоставьте код на языке SQL, который обновляет представление analysis.Orders.

Создайте документ orders_view.sql и сохраните в нём написанный запрос.


### Как запустить контейнер
Запустите локально команду:

```
docker run -d --rm -p 3030:3030 -p 3000:3000 --name=de-project-sprint-1-server-local sindb/project-sprint-1:latest
```

После того как запустится контейнер, у вас будут доступны:
1. VS Code
2. CloudBeaver
3. PostgreSQL (запросы лучше выполнять через CloudBeaver)
